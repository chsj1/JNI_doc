#JNI的作用与工作原理
===========================
本文主要翻译自Java JNI文档。
用接口的方式联接不同的编程语言并非什么新观念。例如，C语言通常可以调用FORTRAN和汇编语言编写的函数。同样的，
Lisp和Smalltalk的实现也支持很多其他语言的接口。  
JNI要解决的问题和其他支持协作机制的语言要解决的问题一样。但是，二者间有个重要的区别：JNI并非为特定的JVM实
现而设计，而是为所有JVM实现都支持的本地接口而设计。我们会在描述JNI设计目标的过程中详细说明这点。

##设计目标
JNI设计的最重要目标，就是支持针对不同本地环境的各种JVM实现之间的二进制兼容。  
**本地环境(Host Environment)**
- 又称为系统环境，有自己的本地库和CPU指令集
- 本地程序使用C/C++这样的本地语言来编写，编写的程序链接本地库，并在本地环境中运行
- 本地程序和本地库都依赖一个特定的本地系统环境  

JNI设计的第二个目标是高效。有时为了满足第一个目标，可能会牺牲一点小利，因此需要在平台无关和效率之间做一些
权衡。

最后，JNI必须是一个完整的体系。它必须公开足够多的JVM功能，以使本地程序完成一些有意义的任务。

##加载本地库
在程序能够调用本地接口之前，虚拟机必须定位和加载那些实现了这些接口的本地库。

###类加载器
本地库是通过类加载器来定位的。  
**类加载器(Class Loader)**
- Java类加载器基于三个机制：委托、可见性和单一性
- 委托机制是指将加载一个类的请求交给父类加载器，如果这个父类加载器不能够找到或者加载这个类，那么再加载它。
- 可见性的原理是子类的加载器可以看见所有的父类加载器加载的类，而父类加载器看不到子类加载器加载的类。
- 单一性原理是指仅加载一个类一次，这是由委托机制确保子类加载器不会再次加载父类加载器加载过的类。
- 有三种默认使用的类加载器：Bootstrap类加载器、Extension类加载器和System类加载器（或者叫作Application类加载器）。
每种类加载器都有设定好从哪里加载类。[查看更详细的机制](http://www.importnew.com/6581.html)

###类加载器与本地库
假设两个同名类C里面都有一个f方法（签名不一样），虚拟机用同一个名字C_f来对两个C.f方法的本地实现来定位。为了保证每个
类链接到正确的本地函数，每个类加载器必须维护一个与自己相关联的本地库的集合（相当于所有的本地方法定义在同一个文件里，
那么两个签名不同的方法自然而然可以区分开）。  
这样，只要类拥有相同的类加载器，开发者就可以使用单一的本地库库来存储在任意类里面使用的本地方法。  
当类被加载器回收时，本地库也会被JVM自动unload。  

###定位本地库
本地库通过System.loadLibrary方法加载。在下面的例子中，类Cls静态初始化时加载了一个本地库。
```java
package pkg; 

class Cls {
    native double f(int i, String s);
    static {
      System.loadLibrary("mypkg");
    }
 }
```
JVM会根据当前系统环境的不同，把库的名字转换成相应的本地库名字。例如，Solaris下，mypkg会被转化成libmypkg.so，而Win32
环境下，被转化成mypkg.dll。  
JVM在启动的时候，会生成一个本地库的目录列表，这个列表的具体内容依赖于当前的系统环境，比如Win32下，这个列表中会包含
Windows系统目录、当前工作目录、PATH环境变量里面的目录。  
System.loadLibrary在加载相应本地库失败时，会抛出UnsatisfiedLinkError错误。如果相应的库已经加载过，这个方法不做任何
事情。如果底层操作系统不支持动态链接，那么所有的本地方法必须被prelink到VM上，这样的话，VM中调用System.loadLibrary
时实际上没有加载任何库。  

JVM内部为每一个类加载器都维护了一个已经加载的本地库的列表。它通过三步来决定一个新加载的本地库应该和哪个类加载器关联。
- 确定System.loadLibrary的调用者。
- 确定定义调用者的类。
- 确定类的加载器。
所以上述例子中，JVM会把mypkg与Cls的加载器关联起来  

###类型安全约束
VM不允许一个本地库被多个类加载器加载。当一个JNI本地库已经被第一个类加载器加载后，第二个类加载器再加载时，会报
UnsatisfiedLinkError。这样规定的目的是为了确保基于类加载器的命名空间分隔机制在本地库中同样有效。如果不这样的话，通
过本地方法进行操作JVM时，很容易造成属于不同类加载器的类和接口的混乱。  
下面代码中，本地方法Foo.f中缓存了一个全局引用，指向类Foo：
```C
JNIEXPORT void JNICALL

Java_Foo_f(JNIEnv *env, jobject self)
{
  static jclass cachedFooClass; /* cached class Foo */
  if (cachedFooClass == NULL) {
    jclass fooClass = (*env)->FindClass(env, "Foo");
    if (fooClass == NULL) {
      return; /* error */
    }
    cachedFooClass = (*env)->NewGlobalRef(env, fooClass);
    if (cachedFooClass == NULL) {
      return; /* error */
    }
  }

  assert((*env)->IsInstanceOf(env, self, cachedFooClass));
  ... /* use cachedFooClass */
 }
```
因为Foo.f是一个实例方法，而self指向一个Foo的实例对象，所以，我们认为最后那个assertion会执行成功。但是，如果L1和L2
分别加载了两个不同的Foo类，而这两个Foo类都被链接到Foo.f的实现上的话，assertion可能会执行失败。因为，哪个Foo类的f方
法首先被调用，全局引用cachedFooClass指向的就是哪个Foo类。  

###Unloading 本地库
一旦JVM回收类加载器，与这个类加载器关联的本地库就会被unload。因为类指向它自己的加载器，所以，这意味着，VM也会被这
个类unload。  

##链接本地方法
VM会在第一次使用一个本地方法的时候链接它。假设调用了方法g，而在g的方法体中出现了对方法f的调用，那么本地方法f就会被
链接。VM不应该过早地链接本地方法，因为这时候实现这些本地方法的本地库可能还没有被load，从而导致链接错误。  
链接一个本地方法需要下面这几个步骤：
- 确定定义了本地方法的类的加载器。
- 在加载器所关联的本地库列表中搜索实现了本地方法的本地函数。
- 建立内部数据结构，使得之后的对本地方法的调用能直指本地函数    

VM通过下面这几步，同本地方法的名字生成与之对应的本地函数的名字：
- 前缀“Java_”。
- 类的全名。
- 下划线分隔符“_”。
- 方法名字。
- 有方法重载的情况时，还会有两个下划线（“__”），后面跟着参数描述符。  

虚拟机遍历类定义加载器的所有本地库，以搜索指定名字的本地函数。对每一个库进行搜索时，VM会先搜索短名字（short name），即没有参数描述符的名字。然后搜索长名字（long name），即有参数描述符的名字。当两个本地方法重载时，程序
员需要使用长名字来搜索。但如果一个本地方法和一个非本地方法重载时，就不会使用长名字。  
在下面的例子里，本地方法g不会用长名字链接，因为另一个g并非本地方法：
```java
Class Cls {
  int g(int i) { ... }
  native int g(double d);
}

```
如果多个本地库中都存在与一个编码后的本地方法名字相匹配的本地函数，哪个本地库首先被加载，则它里面的本地函数就与
这个本地方法链接。如果没有哪个函数与给定的本地方法相匹配，则UnsatisfiedLinkError被抛出。  
程序员还可以调用JNI函数RegisterNatives来注册与一个类关联的本地方法。这个JNI函数对静态链接函数非常有用。

##调用协议
调用协议决定了一个本地函数如何接收参数和返回结果。目前没有一个标准，主要取决于编译器和本地语言的不同。JNI要求同
一个系统环境下，调用协议必须相同。例如，JNI在UNIX下使用C调用协议，而在Win32下使用stdcall调用协议。  
如果程序员需要调用的函数遵循不同的调用协议，那么最好写一个转换层来解决这个问题。  

##JNIEnv接口指针
本地代码通过JNIEnv接口指针里暴露的方法来使用虚拟机的功能。

###JNIEnv接口指针的组织结构
JNIEnv是一个指向本地线程数据的接口指针，这个指针里面包含了一个指向函数表的指针。每一个接口函数在这表中都有一个
预定义的偏移位置。JNIEnv很像一个C++虚函数表或者Microsoft COM接口。
